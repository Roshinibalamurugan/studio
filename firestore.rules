/**
 * This ruleset enforces a strict security model for the BookMyShow application.
 *
 * Core Philosophy:
 * The security model is built on two primary principles: strict user ownership for private
 * data and authenticated read-only access for public catalog data. This provides a strong
 * default security posture, protecting user privacy while allowing the app to function.
 *
 * Data Structure:
 * - /users/{userId}: Contains user profile information. This path is the root for all
 *   private user data.
 * - /users/{userId}/bookings/{bookingId}: A subcollection containing all bookings made by
 *   a specific user.
 * - /movies, /theaters, /showtimes: Top-level collections that store public-facing
 *   information. All authenticated users can read this data, but no client can write to it,
 *   preventing tampering with shared application content.
 *
 * Key Security Decisions:
 * - User Data Isolation: All user-specific data (profiles, bookings) is nested under
 *   `/users/{userId}`. Rules ensure that only the authenticated owner of that data
 *   can access or modify it.
 * - No User Enumeration: Listing documents in the top-level `/users` collection is
 *   explicitly forbidden to protect user privacy and prevent scraping of user lists.
 * - Client-Side Write Protection for Public Data: To maintain data integrity, all writes
 *   (create, update, delete) to the public `/movies`, `/theaters`, and `/showtimes`
 *   collections are disabled. This data is expected to be managed by a trusted backend
 *   service using the Firebase Admin SDK.
 *
 * Denormalization for Authorization:
 * The `Booking` entity contains a `userId` field. Security rules validate on creation and
 * enforce immutability on update for this field, ensuring a booking is always tied to the
 * correct user without requiring expensive cross-document lookups.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //----------------------------------------------------------------//
    // Helper Functions
    //----------------------------------------------------------------//

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner and the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    //----------------------------------------------------------------//
    // Collection Rules
    //----------------------------------------------------------------//

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user (uid: 'user123') creating their own profile at /users/user123.
     * @deny (get) A user (uid: 'user456') trying to read the profile of 'user123'.
     * @principle "Users can only create, read, update, and delete their own profile."
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's bookings.
       * @path /users/{userId}/bookings/{bookingId}
       * @allow (create) A signed-in user (uid: 'user123') creating a booking for themselves under /users/user123/bookings/booking_abc.
       * @deny (list) User 'user456' trying to list bookings for 'user123'.
       * @principle "Restricts all access to a user's own data tree."
       */
      match /bookings/{bookingId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Publicly readable movie data.
     * @path /movies/{movieId}
     * @allow (get) Any signed-in user reading movie details.
     * @deny (create) Any user trying to add a new movie.
     * @principle "Data is readable by any authenticated user but is not writable from the client."
     */
    match /movies/{movieId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly readable theater data.
     * @path /theaters/{theaterId}
     * @allow (list) Any signed-in user listing all available theaters.
     * @deny (update) Any user trying to change a theater's location.
     * @principle "Data is readable by any authenticated user but is not writable from the client."
     */
    match /theaters/{theaterId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly readable showtime data.
     * @path /showtimes/{showtimeId}
     * @allow (get) Any signed-in user fetching a specific showtime.
     * @deny (delete) Any user trying to cancel a showtime.
     * @principle "Data is readable by any authenticated user but is not writable from the client."
     */
    match /showtimes/{showtimeId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}

    